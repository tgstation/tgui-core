import {
  type CSSProperties,
  createElement,
  type KeyboardEventHandler,
  type MouseEventHandler,
  type ReactNode,
  type UIEventHandler,
  useMemo,
} from 'react';
import type { BooleanLike } from '../common/react';
import {
  type BooleanStyleMap,
  computeBoxClassName,
  computeBoxProps,
  computeTwClass,
  type StringStyleMap,
} from '../common/ui';

type EventHandlers<TElement = HTMLDivElement> = {
  onClick: MouseEventHandler<TElement>;
  onContextMenu: MouseEventHandler<TElement>;
  onDoubleClick: MouseEventHandler<TElement>;
  onKeyDown: KeyboardEventHandler<TElement>;
  onKeyUp: KeyboardEventHandler<TElement>;
  onMouseDown: MouseEventHandler<TElement>;
  onMouseLeave: MouseEventHandler<TElement>;
  onMouseMove: MouseEventHandler<TElement>;
  onMouseOver: MouseEventHandler<TElement>;
  onMouseUp: MouseEventHandler<TElement>;
  onScroll: UIEventHandler<TElement>;
};

type InternalProps = {
  /** The component used for the root node. */
  as: string;
  /** The content of the component. */
  children: ReactNode;
  /** Class name to pass into the component. */
  className: string | BooleanLike;
  /** The unique id of the component. */
  id: string;
  /** The inline style of the component. */
  style: CSSProperties;
  /**
   * ### tw
   * A shorthand classname syntax based loosely on tailwind.
   *
   * This takes all Box style props with a dash separator for params, e.g.'mb-4' or the prop name alone e.g. 'bold'.
   *
   * It's compatible with regular Box props, even on the same component, but it will take precedence.
   *
   * ### Example:
   * ```tsx
   * <Box tw="mb-2 bold fontSize-16px">
   *  // Is equivalent to
   * <Box mb={2} bold fontSize="16px">
   *  ```
   *
   * ### Caveats:
   * 1. You can't use this for custom props from other components.
   *
   * 2. There is no type info or safety for this method. Like the old days, it simply won't work if you use it incorrectly.
   *
   * 3. This should be a static string with minimal interpolation. If you need more logic, prefer the props approach.
   */
  tw: string;
};

// You may wonder why we don't just use ComponentProps<typeof Box> here.
// This is because I'm trying to isolate DangerDoNotUse from the rest of the props.
// While you still can technically use ComponentProps, it won't throw an error if someone uses dangerouslySet.
export type BoxProps<TElement = HTMLDivElement> = Partial<
  InternalProps & BooleanStyleMap & StringStyleMap & EventHandlers<TElement>
>;

// Don't you dare put this elsewhere
type DangerDoNotUse = {
  dangerouslySetInnerHTML?: {
    __html: any;
  };
};

/**
 * ## Box
 * The Box component serves as a wrapper component for most of the CSS utility
 * needs. It creates a new DOM element, a `<div>` by default that can be changed
 * with the `as` property. Let's say you want to use a `<span>` instead:
 *
 * @example
 * ```tsx
 * <Box as="span" m={1}>
 *   <Button />
 * </Box>
 * ```
 *
 * This works great when the changes can be isolated to a new DOM element.
 * For instance, you can change the margin this way.
 *
 * However, sometimes you have to target the underlying DOM element.
 * For instance, you want to change the text color of the button. The Button
 * component defines its own color. CSS inheritance doesn't help.
 *
 * To workaround this problem, the Box children accept a render props function.
 * This way, `Button` can pull out the `className` generated by the `Box`.
 *
 * @example
 * ```tsx
 * <Box color="primary">{(props) => <Button {...props} />}</Box>
 * ```
 *
 * ## Box Units
 *
 * `Box` units, like width, height and margins can be defined in two ways:
 *
 * - By plain numbers
 *   - 1 unit equals `1rem` for width, height and positioning properties.
 *   - 1 unit equals `0.5rem` for margins and paddings.
 * - By strings with proper CSS units
 *   - For example: `100px`, `2em`, `1rem`, `100%`, etc.
 *
 * If you need more precision, you can always use fractional numbers.
 *
 * Default font size (`1rem`) is equal to `12px`.
 */
export function Box<TElement = HTMLDivElement>(
  props: BoxProps<TElement> & DangerDoNotUse,
) {
  const { as = 'div', className, children, tw, ...rest } = props;

  const computedClassName = useMemo(() => {
    if (className) {
      return `${className} ${computeBoxClassName<TElement>(rest)}`;
    }
    return computeBoxClassName<TElement>(rest);
  }, [className, rest]);

  const computedProps = useMemo(() => {
    return computeBoxProps({
      ...rest,
      ...computeTwClass(tw),
    });
  }, [rest, tw]);

  return createElement(
    as,
    {
      ...computedProps,
      className: computedClassName,
    },
    children,
  );
}
