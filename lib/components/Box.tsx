import {
  type CSSProperties,
  type KeyboardEventHandler,
  type MouseEventHandler,
  type ReactNode,
  type UIEventHandler,
  createElement,
} from 'react';
import type { BooleanLike } from '../common/react';
import {
  type BooleanStyleMap,
  type StringStyleMap,
  computeBoxClassName,
  computeBoxProps,
} from '../common/ui';

type EventHandlers = {
  onClick: MouseEventHandler<HTMLDivElement>;
  onContextMenu: MouseEventHandler<HTMLDivElement>;
  onDoubleClick: MouseEventHandler<HTMLDivElement>;
  onKeyDown: KeyboardEventHandler<HTMLDivElement>;
  onKeyUp: KeyboardEventHandler<HTMLDivElement>;
  onMouseDown: MouseEventHandler<HTMLDivElement>;
  onMouseLeave: MouseEventHandler<HTMLDivElement>;
  onMouseMove: MouseEventHandler<HTMLDivElement>;
  onMouseOver: MouseEventHandler<HTMLDivElement>;
  onMouseUp: MouseEventHandler<HTMLDivElement>;
  onScroll: UIEventHandler<HTMLDivElement>;
};

type InternalProps = {
  as: string;
  children: ReactNode;
  className: string | BooleanLike;
  id: string;
  style: CSSProperties;
};

// You may wonder why we don't just use ComponentProps<typeof Box> here.
// This is because I'm trying to isolate DangerDoNotUse from the rest of the props.
// While you still can technically use ComponentProps, it won't throw an error if someone uses dangerouslySet.
export type BoxProps = Partial<
  InternalProps & BooleanStyleMap & StringStyleMap & EventHandlers
>;

// Don't you dare put this elsewhere
type DangerDoNotUse = {
  dangerouslySetInnerHTML?: {
    __html: any;
  };
};

/**
 * # Box
 *
 * The Box component serves as a wrapper component for most of the CSS utility
 * needs. It creates a new DOM element, a `<div>` by default that can be changed
 * with the `as` property. Let's say you want to use a `<span>` instead:
 *
 * @example
 * ```tsx
 * <Box as="span" m={1}>
 *   <Button />
 * </Box>
 * ```
 *
 * This works great when the changes can be isolated to a new DOM element.
 * For instance, you can change the margin this way.
 *
 * However, sometimes you have to target the underlying DOM element.
 * For instance, you want to change the text color of the button. The Button
 * component defines its own color. CSS inheritance doesn't help.
 *
 * To workaround this problem, the Box children accept a render props function.
 * This way, `Button` can pull out the `className` generated by the `Box`.
 *
 * @example
 * ```tsx
 * <Box color="primary">{(props) => <Button {...props} />}</Box>
 * ```
 *
 * ## Box Units
 *
 * `Box` units, like width, height and margins can be defined in two ways:
 *
 * - By plain numbers
 *   - 1 unit equals `1rem` for width, height and positioning properties.
 *   - 1 unit equals `0.5rem` for margins and paddings.
 * - By strings with proper CSS units
 *   - For example: `100px`, `2em`, `1rem`, `100%`, etc.
 *
 * If you need more precision, you can always use fractional numbers.
 *
 * Default font size (`1rem`) is equal to `12px`.
 */
export function Box(props: BoxProps & DangerDoNotUse) {
  const { as = 'div', className, children, ...rest } = props;

  const computedClassName = className
    ? `${className} ${computeBoxClassName(rest)}`
    : computeBoxClassName(rest);
  const computedProps = computeBoxProps(rest);

  return createElement(
    as,
    {
      ...computedProps,
      className: computedClassName,
    },
    children,
  );
}
